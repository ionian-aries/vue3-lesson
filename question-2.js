// c d e       2,3,4
// e c d h     4,2,3,0  // 0 表示以前不存在 



// [c,d]
// [0,1] // 通过上面的两个序列，可以求出来，最终这样的结果，就可以保证某些元素不用移动


// 需要求，连续性最强的子序列 
// 贪心算法  +  二分查找

// 2 2 3 7 6

// 2 2 3 6
// 2 2 3 7

// 数
// 2 3 1 5 6 8 7 9 4 2 -> 最长递增子序列的个数是多少个

// 2  (2的前一个是null)
// 2 3 (3的前一个是2)
// 1 3 (1的前一个是null)
// 1 3 5 (5的前一个是3)
// 1 3 5 6 (6的前一个是5)
// 1 3 5 6 8 (8的前一个是6)
// 1 3 5 6 7 (7的前一个是6)
// 1 3 5 6 7 9 (9的前一个是7)
// 1 3 4 6 7 9 (4的前一个就是3)
// 1 2  4 6 7 9 (2的前一个是1)

// 树 的前驱节点



// 9 7 6  5 3  2


// 找更有潜力的 


// 2 3 7 8
// 2 3 8 9

// 组件的渲染